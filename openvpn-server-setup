#!/bin/bash

##
# openvpn-server-setup designed to help OpenVPN server setup on CentOS 6/7 or
# Ubuntu Xenial 16.04.
# It can be used for stock openvpn server configuration.
# For customizations you still need manually tune configuration.
#
# You can execute this script on remote host via ssh:
#   ssh user@host 'sudo bash -s' -- <'/local/path/to/openvpn-server-setup'
# Or copy to remote host and run:
#   sudo bash /path/to/openvpn-server-setup [--mssfix | --link-mtu]
# Option mssfix or link-mtu (default) is used to specify confguration type:
#   mssfix generally more stable but less resistant to openvpn connection tracking by web sites.
# You can change behavoir after creation by modifying server and client
# configs (comment/uncomment corresponding lines).
#
# openvpn-manage configuration tool embedded to this script and will be available after setup.
# It helps you to manage openvpn users.
##


## Defaults
SERVER_LOCAL_IF='eth0'
link_mtu=';link-mtu'
mssfix='mssfix'


##
# Exit with optional message to stderr
##
quit() {
    [[ $2 ]] && echo "$2" >&2
    exit "${1:-0}"
}


##
# Validate IPv4 address
# Note: this is invalid address: 192.168.000.001
##
validate_ip4() {
    local _re
    _re='^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'
    [[ "$1" =~ ${_re} ]] && return 0 || return 1
}


((UID)) && quit 1 "You are not root. Try: sudo $0 $*"
BR=$'\n'  # Newline alias


## Decide which way preferred: mssfix or link-mtu
if [[ ${1::1} == '-' ]]; then  # First arg is an option
    opt=${1#${1%%[^-]*}}  # Remove leading hyphens
    if [[ "${opt}" == 'mssfix' ]]; then
        link_mtu=';link-mtu'
        mssfix='mssfix'
    elif [[ "${opt}" == 'link-mtu' ]]; then
        link_mtu='link-mtu'
        mssfix=';mssfix'
    else
        quit 1 "Invalid option: $1"
    fi
fi

## Check OS
if [[ -f /etc/redhat-release ]]; then
    OS_family=RedHat

    ## Get CentOS major version
    CentOS_major=$(exec -c sed -n 's/.* \([0-9]\+\)\.\?.*/\1/p' /etc/redhat-release)

    if ! ((CentOS_major == 6 || CentOS_major == 7)); then
        quit 1 'Only CentOS 6 & 7 supported for RedHat family, check your CentOS version in /etc/redhat-release'
    fi
    echo "CentOS major version detected: ${CentOS_major}"

    OS=CentOS

    ## You could want to upgrade the system to latest state if it's created from scratch
    # yum -y -d0 upgrade

    case "${CentOS_major}" in
        7)
            echo 'Adding epel repo'
            rpm -ivh --replacepkgs "http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm"
            (($?==0)) || quit 1 'Failed to add epel repo'

            echo 'Disable and stop firewalld if exists'
            systemctl disable firewalld
            systemctl stop firewalld
            echo 'Install, start and enable iptables-services'
            yum -y -d0 install iptables-services
            systemctl enable iptables
            systemctl start iptables
            ;;
        6)
            echo 'Fix ancient ca-certs'
            yum --disablerepo=epel -y -d1 update ca-certificates

            echo 'Adding epel repo'
            rpm -ivh --replacepkgs "http://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm"
            (($?==0)) || quit 1 'Failed to install epel repo'
            # echo 'Changing epel repo to use http instead of https because of ancient ca-certs'
            # sed -i 's|https://|http://|g' /etc/yum.repos.d/epel*.repo
            ;;
    esac
    (($?==0)) || quit 1 'Failed to install epel repo'
elif [[ -f /etc/debian_version ]]; then
    OS_family=Debian
    if grep -q ' xenial ' /etc/apt/sources.list; then
        OS=Ubuntu
        OS_release=Xenial
    # elif grep -q ' stretch ' /etc/apt/sources.list; then
    #     OS=Debian
    #     OS_release=Stretch
    else
        quit 1 'Only Ubuntu Xenial 16.04 supported for Debian family'
    fi
else
    quit 1 'Unsupported OS family'
fi


case "${OS_family}" in
    RedHat)
        echo 'Installing required packages'
        yum -y -d0 install openvpn zip unzip iptables iproute bind-utils wget openssl
        (($?==0)) || quit 1 'Failed to install required packages'
        ;;
    Debian)
        if [[ "${OS_release}" != Stretch ]]; then
            echo 'Add official openvpn repo'  # See https://community.openvpn.net/openvpn/wiki/OpenvpnSoftwareRepos
            wget -nv -O - https://swupdate.openvpn.net/repos/repo-public.gpg | apt-key add -
            echo "deb http://build.openvpn.net/debian/openvpn/stable ${OS_release,,} main" >/etc/apt/sources.list.d/openvpn-aptrepo.list
        fi
        echo 'Updating packages list'
        apt-get -yqq update
        echo 'Installing required packages'
        apt-get -yq install openvpn zip unzip iptables iproute2 wget dnsutils openssl netfilter-persistent
        ;;
esac
(($?==0)) || quit 1 'Failed to install required packages'

echo 'Check openvpn version (should be >=2.4)'
openvpn --version | head -1
(($?==0)) || quit 1 'Failed to check openvpn version'

SERVER_LOCAL_IP=$(ip address show "${SERVER_LOCAL_IF}" | sed -n 's/ \+inet \([0-9.]\+\).*/\1/p' 2>/dev/null | grep -v 127.0.0.1 | head -1)
echo 'Existing host IPv4 non-local interfaces:'
# hostname -I
ip -o -4 address | grep -v -e ': lo ' -e ': tun[0-9]\+ ' -e ': tap[0-9]\+ '
if [[ -z ${SERVER_LOCAL_IP} ]]; then
    echo "Cannot detect local IP for ${SERVER_LOCAL_IF} interface."
    echo -n "Input local IP for desired interface and press enter: "
    read SERVER_LOCAL_IP
    if ! grep -q " inet ${SERVER_LOCAL_IP}/" < <(exec -c ip -o -4 address); then
        quit 1 "No such local IP assigned to any interface: ${SERVER_LOCAL_IP}"
    fi
    SERVER_LOCAL_IF=$(ifconfig | grep -B1 "inet addr:${SERVER_LOCAL_IP}" | awk '$1!="inet" && $1!="--" {print $1}' | cut -d: -f1)
fi
echo "Server local interface name: ${SERVER_LOCAL_IF}"
echo "Server local IP for openvpn server: ${SERVER_LOCAL_IP}"
# Server public IP or domain
SERVER_PUBLIC_IP=$(dig -4 -b "${SERVER_LOCAL_IP}" +short +time=3 +retry=1 myip.opendns.com @208.67.222.222)
if ! validate_ip4 "${SERVER_PUBLIC_IP}"; then
    echo "Cannot detect public IP of interface ${SERVER_LOCAL_IF}"
    echo -n 'Input interface name: '
    read SERVER_LOCAL_IF
    if ! [[ -L "/sys/class/net/${SERVER_LOCAL_IF}" ]]; then
        quit 1 "No such interface: ${SERVER_LOCAL_IF}"
    fi
    echo -n 'Input local IP: '
    read SERVER_LOCAL_IP
    if ! grep -q " inet ${SERVER_LOCAL_IP}/" < <(exec -c ip address); then
        quit 1 "No such local IP assigned to any interface: ${SERVER_LOCAL_IP}"
    fi
    SERVER_PUBLIC_IP=$(dig -4 -b "${SERVER_LOCAL_IP}" +short +time=3 +retry=1 myip.opendns.com @208.67.222.222)
    if ! validate_ip4 "${SERVER_PUBLIC_IP}"; then
        echo -n "Cannot detect public IP of interface ${SERVER_LOCAL_IF}"
        echo -n "Input public IP: "
        read SERVER_PUBLIC_IP
    fi
else
    echo "Server public IP detected: ${SERVER_PUBLIC_IP}"
fi

## Change work dir
mkdir -p /etc/openvpn
cd /etc/openvpn

## Clear some dirs if any
[[ -d /etc/openvpn/server ]]   && rm -rvf /etc/openvpn/server
[[ -d /etc/openvpn/easy-rsa ]] && rm -rvf /etc/openvpn/easy-rsa
[[ -d /etc/openvpn/chroot ]]   && rm -rvf /etc/openvpn/chroot

echo 'Downloading easyrsa pack'
wget -nv https://github.com/vmspike/openvpn-manage/raw/master/easyrsa3.zip  # Better to use your own link for this pack
(($?==0)) || quit 1 'Failed to download easyrsa3.zip pack'
## Alternatively if you have it locally, run from your PC (for Windows you can use MobaXterm or Putty):
# scp ./easyrsa3.zip user@host:~/
## And move to /etc/openvpn on server side:
# mv ~user/easyrsa3.zip /etc/openvpn

## Some actions to setup easyrsa
unzip -q easyrsa3.zip
(($?==0)) || quit 1 'Failed to unzip easyrsa3.zip pack'
rm -f easyrsa3.zip
mv easy-rsa-master easy-rsa
cd /etc/openvpn/easy-rsa/easyrsa3
./easyrsa --batch init-pki

## Will ask for common name if no --batch specified
## Example: Gabriel (default: Easy-RSA CA; batch default: ChangeMe)
./easyrsa --batch build-ca nopass

./easyrsa --batch gen-crl
./easyrsa --batch gen-req server nopass
./easyrsa --batch sign-req server server
./easyrsa --batch gen-dh  # Can take few minutes depends on CPU

## User openvpn already should be present but if not add it
if ! getent passwd openvpn &>/dev/null; then
    case "${OS_family}" in
        RedHat)
            adduser --system --no-create-home --home-dir /etc/openvpn --shell /sbin/nologin --gid openvpn
            ;;
        Debian)
            adduser --system --no-create-home --home /nonexistent --disabled-login --group openvpn
            ;;
    esac
fi

mkdir -p /etc/openvpn/server/{client-configs,client-keys,client-packs,keys,scripts}
openvpn --genkey --secret /etc/openvpn/easy-rsa/easyrsa3/pki/ta.key
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/ca.crt /etc/openvpn/server/keys/
# ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem /etc/openvpn/server/keys/
ln -s /etc/openvpn/chroot/crl.pem /etc/openvpn/server/keys/
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/dh.pem /etc/openvpn/server/keys/
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/issued/server.crt /etc/openvpn/server/keys/
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/private/server.key /etc/openvpn/server/keys/
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/ta.key /etc/openvpn/server/keys/ta.key
mkdir -p /var/log/openvpn
chown -R :openvpn /etc/openvpn/server/keys/ /var/log/openvpn /etc/openvpn/easy-rsa/easyrsa3/pki
chmod 400 /etc/openvpn/easy-rsa/easyrsa3/pki/{ca.crt,dh.pem,issued/server.crt,private/server.key,ta.key}
chmod 750 /etc/openvpn/server/keys
chmod 710 /etc/openvpn/easy-rsa/easyrsa3/pki/
chmod 440 /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem
touch /etc/openvpn/server/{tcp,udp}.server.conf
chown -R root:openvpn /var/log/openvpn
chmod 755 /var/log/openvpn/
ln -s ./server/tcp.server.conf /etc/openvpn/tcp.server.conf
ln -s ./server/udp.server.conf /etc/openvpn/udp.server.conf

## Preparations for openvpn-manage
ln -s /etc/openvpn/server/scripts/openvpn-manage /usr/local/bin/  # So it will be available globally if /usr/localb/in in PATH environmental variable
touch /etc/openvpn/server/users-config
chown :openvpn /etc/openvpn/server/users-config
chmod 640 /etc/openvpn/server/users-config

## Preparations for chrooted environment
mkdir -p /etc/openvpn/chroot/{ccd,tmp,scripts,bin,etc}
chown root:openvpn /etc/openvpn/chroot/tmp
chmod 775 /etc/openvpn/chroot/tmp
cp -pf /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem /etc/openvpn/chroot/
# ln -s /etc/openvpn/chroot/crl.pem /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem
touch /etc/openvpn/chroot/scripts/learn-address
chown root:openvpn /etc/openvpn/chroot/scripts/*
chmod 754 /etc/openvpn/chroot/scripts/*
mv /etc/openvpn/server/users-config /etc/openvpn/chroot/
ln -s ../chroot/users-config /etc/openvpn/server/users-config

## Copy openvpn-manage to /etc/openvpn/server/scripts/
# wget -nv https://github.com/vmspike/openvpn-manage/raw/master/openvpn-manage -O /etc/openvpn/server/scripts/openvpn-manage
read -rd '' OPENVPN_MANAGE <<'EOF_OPENVPN_MANAGE'
#!/bin/bash

##
# Exit with optional message to stderr
##
quit() {
    [[ $2 ]] && echo "$2" >&2
    exit "${1:-0}"
}


##
# Convert decimal number to IPv4 address
##
dec2ip() {
    local _var _res _e _dot _octet _dec
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    _dec=$1
    for _e in {3..0}; do
        (( _octet = _dec/256**_e ))
        (( _dec -= _octet*256**_e ))
        _res+=${_dot}${_octet}
        _dot=.
    done

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Convert IPv4 address to decimal number
##
ip2dec() {
    local _var _res _a _b _c _d
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    IFS=. read -r _a _b _c _d <<<"$1"
    (( _res = _a*256**3 + _b*256**2 + _c*256 + _d ))

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Convert IPv4 MASK to CIDR
# Assumes that MASK have no gaps.
##
mask2cidr() {
    local _var _res _x
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    _x=${1##*255.}
    set -- 0^^^128^192^224^240^248^252^254^ $(( (${#1}-${#_x})*2 )) "${_x%%.*}"
    _x=${1%%$3*}
    (( _res = $2 + ${#_x}/4 ))

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Convert CIDR to IPv4 MASK
##
cidr2mask() {
    local _var _res
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi
    [[ -z $1 ]] && set 0

    set -- $(( 5-($1/8) )) 255 255 255 255 $(( (255<<(8 - ($1%8)))&255 )) 0 0 0
    if (($1 > 1)); then shift "$1"; else shift; fi
    _res=${1:-0}.${2:-0}.${3:-0}.${4:-0}

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Return next subnet with the same size
# Subnet format is IPv4/CIDR
##
increment_subnet() {
    local _var _res _ip _cidr _size _ip_dec _ip_next
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    _ip=${1%/*}
    _cidr=${1#*/}
    (( _size = 2**(32-_cidr) ))  # all IPs count inside subnet e.g. /29 size is 8
    ip2dec -v _ip_dec "${_ip}"
    dec2ip -v _ip_next $((_size+_ip_dec))
    _res=${_ip_next}/${_cidr}

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Validate IPv4 address
# Note: this is invalid address: 192.168.000.001
##
validate_ip4() {
    local _re
    _re='^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'
    [[ "$1" =~ ${_re} ]] && return 0 || return 1
}


##
# Validate IPv4/CIDR
##
validate_ip4cidr() {
    local _re
    _re='^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\/([0-9]|[1-2][0-9]|3[0-2])$'
    [[ "$1" =~ ${_re} ]] && return 0 || return 1
}


##
# Usage: validate_host_name host_name [regex]
##
validate_host_name() {
    local _re
    if [[ $2 ]]; then
        _re=$2
    elif [[ ${HOST_NAME_ALLOWED_REGEX} ]]; then
        _re=${HOST_NAME_ALLOWED_REGEX}
    else
        _re='^[A-Za-z0-9_-]+$'  # Default regex
    fi
    [[ "$1" =~ ${_re} ]] || quit 1 "Host name restricted to match the following regex: ${_re}"
    return 0
}


##
# Validate that client name starts with 5 digits and '-' then.
# Values '00000-' and '00001-' treated as invalid.
# Include host name validation.
##
validate_client_name() {
    local _re _N
    _re='^[0-9]+-$'
    _N=${1::6}
    [[ "${_N}" =~ ${_re} && "${_N}" != '00000-' && "${_N}" != '00001-' ]] || quit 1 "First 6 symbols of client name must match the following regex: ${_re}"
    validate_host_name "${1:6}" || return 1
    return 0
}


revoke_cert() {
    local _cn
    _cn=$1
    [[ -f "${EASYRSA}/pki/issued/${_cn}.crt" ]] || quit 1 "No such cert: ${_cn}"
    if ! grep -qE "^R[[:space:]]*[[:digit:]]*Z.*/CN=${_cn}(/.*)?$" "${EASYRSA}/pki/index.txt"; then
        ./easyrsa --batch revoke "${_cn}" &>"${DESCRIPTOR}"
        if (($?)); then
            quit 1 "${_cn}: failed to revoke cert"
        else
            echo "${_cn}: cert revoked"
        fi
    else
        echo "${_cn}: cert already revoked!"
    fi
}


disable_client() {
    local _cn
    _cn=$1
    if ! grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${_cn}"; then
        echo disable >>"${CLIENT_CONFIG_DIR}/${_cn}"
        echo "${_cn}: disabled"
    else
        echo "${_cn}: was already disabled!"
    fi
}


enable_client() {
    local _cn
    _cn=$1
    if grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${_cn}"; then
        sed -i '/^disable$/d' "${CLIENT_CONFIG_DIR}/${_cn}"
        echo "${_cn}: enabled"
    else
        echo "${_cn}: was already enabled!"
    fi
}


populate_subnet_var() {
    local _cn CLIENT_SUBNET_BEHIND_IP CLIENT_SUBNET_BEHIND_CIDR ROUTERS_LIST FIRST_ROUTER
    _cn=$1
    ROUTERS_LIST=$(exec -c grep -l '^iroute ' "${CLIENT_CONFIG_DIR}/"*"-${_cn}")
    if (($? == 0)); then  # Other routers exists for this host
        # Get subnet from first available router config of this host!
        read -r FIRST_ROUTER <<<"${ROUTERS_LIST}"
        CLIENT_SUBNET_BEHIND=$(exec -c grep -m1 '^iroute ' "${FIRST_ROUTER}")
        CLIENT_SUBNET_BEHIND=${CLIENT_SUBNET_BEHIND#iroute }
        CLIENT_SUBNET_BEHIND_IP=${CLIENT_SUBNET_BEHIND%% *}
        mask2cidr -v CLIENT_SUBNET_BEHIND_CIDR ${CLIENT_SUBNET_BEHIND#* }
        CLIENT_SUBNET_BEHIND=${CLIENT_SUBNET_BEHIND_IP}/${CLIENT_SUBNET_BEHIND_CIDR}
    else  # It's only router for this host: autoincrement subnet
        # Increment last saved subnet
        if [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]]; then
            increment_subnet -v CLIENT_SUBNET_BEHIND "$(< "${LAST_IROUTE_SUBNET_FILE}")"
        else
            CLIENT_SUBNET_BEHIND=${INITIAL_IROUTE_SUBNET}
        fi
        [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]] && mv "${LAST_IROUTE_SUBNET_FILE}"{,.old}
        echo "${CLIENT_SUBNET_BEHIND}" >"${LAST_IROUTE_SUBNET_FILE}"
        echo "Note: LAST_IROUTE_SUBNET was incremented to ${CLIENT_SUBNET_BEHIND}" >&2
    fi
}


update_client() {
    # Update client type and/or subnet
    local _cn OLD_CLIENT_TYPE OLD_IROUTE CLIENT_SUBNET_BEHIND_IP CLIENT_SUBNET_BEHIND_MASK OLD_CLIENT_SUBNET_BEHIND OLD_CLIENT_SUBNET_BEHIND_IP OLD_CLIENT_SUBNET_BEHIND_CIDR
    _cn=$1
    if grep -q '^iroute ' "${CLIENT_CONFIG_DIR}/${_cn}"; then
        OLD_CLIENT_TYPE=router
        OLD_IROUTE=$(exec -c grep -m1 '^iroute ' "${CLIENT_CONFIG_DIR}/${_cn}")
        OLD_CLIENT_SUBNET_BEHIND=${OLD_IROUTE#iroute }
        OLD_CLIENT_SUBNET_BEHIND_IP=${OLD_CLIENT_SUBNET_BEHIND%% *}
        mask2cidr -v OLD_CLIENT_SUBNET_BEHIND_CIDR ${OLD_CLIENT_SUBNET_BEHIND#* }
        OLD_CLIENT_SUBNET_BEHIND=${OLD_CLIENT_SUBNET_BEHIND_IP}/${OLD_CLIENT_SUBNET_BEHIND_CIDR}
    else
        OLD_CLIENT_TYPE=user
    fi

    case "${CLIENT_TYPE}" in
        user)
            if [[ "${CLIENT_TYPE}" != "${OLD_CLIENT_TYPE}" ]]; then  # router -> user
                sed -i -e '/^iroute /d' -e "1 a config ${USERS_CONF_IN_CHROOT}" "${CLIENT_CONFIG_DIR}/${_cn}"
                echo "${_cn}: type changed to ${CLIENT_TYPE}"
            else  # user -> user: nothing to change
                echo "${_cn}: type is already ${CLIENT_TYPE}!"
            fi
            ;;
        router)
            if [[ -z "${CLIENT_SUBNET_BEHIND}" ]]; then
                populate_subnet_var "${_cn:6}"
            fi

            CLIENT_SUBNET_BEHIND_IP=${CLIENT_SUBNET_BEHIND%%/*}
            cidr2mask -v CLIENT_SUBNET_BEHIND_MASK ${CLIENT_SUBNET_BEHIND#*/}
            if [[ "${CLIENT_TYPE}" != "${OLD_CLIENT_TYPE}" ]]; then  # user -> router
                sed -i -e '/^config /d' -e "1 a iroute ${CLIENT_SUBNET_BEHIND_IP} ${CLIENT_SUBNET_BEHIND_MASK}" "${CLIENT_CONFIG_DIR}/${_cn}"
                echo "${_cn}: internal subnet changed to ${CLIENT_SUBNET_BEHIND}"
            else  # router -> router: change router subnet only
                if [[ "${OLD_CLIENT_SUBNET_BEHIND}" != "${CLIENT_SUBNET_BEHIND}" ]]; then
                    sed -i "s/${OLD_IROUTE}/iroute ${CLIENT_SUBNET_BEHIND_IP} ${CLIENT_SUBNET_BEHIND_MASK}/" "${CLIENT_CONFIG_DIR}/${_cn}"
                    echo "${_cn}: internal subnet changed to ${CLIENT_SUBNET_BEHIND}"
                else
                    echo "${_cn}: already has internal subnet ${CLIENT_SUBNET_BEHIND}!"
                fi
            fi
            ;;
    esac

    # Enable/disable if -e|-d specified
    [[ "${ENABLED}" == yes ]] && enable_client "${_cn}"
    [[ "${ENABLED}" == no ]] && disable_client "${_cn}"
}


show_client() {
    local CLIENT_NAME ENABLED VALID_CERT CLIENT_TYPE IROUTES IROUTE IP CIDR USERS_CONF_LINE line n N SUBNET CLIENT_CONFIG CCC
    SUBNET=''
    CLIENT_NAME=$1
    CLIENT_CONFIG="${CLIENT_CONFIG_DIR}/${CLIENT_NAME}"
    CCC=$(< "${CLIENT_CONFIG}")

    if grep -q '^disable$' <<<"${CCC}"; then
        ENABLED=no
    else
        ENABLED=yes
    fi

    IROUTES=$(exec -c grep '^iroute ' <<<"${CCC}")
    if (($? == 0)); then
        CLIENT_TYPE=router
        while read IROUTE; do
            IROUTE=${IROUTE#iroute }
            IP=${IROUTE%% *}
            mask2cidr -v CIDR ${IROUTE#* }
            [[ ${SUBNET} ]] && SUBNET+=','
            SUBNET+="${IP}/${CIDR}"
        done <<<"${IROUTES}"
    fi
    USERS_CONF_LINE=$(exec -c grep "^config ${USERS_CONF_IN_CHROOT}$" <<<"${CCC}")
    if (($? == 0)); then
        CLIENT_TYPE=user
    fi
    if [[ -n "${IROUTES}" && -n "${USERS_CONF_LINE}" ]]; then
        CLIENT_TYPE=mixed
    elif [[ -z "${IROUTES}" && -z "${USERS_CONF_LINE}" ]]; then
        CLIENT_TYPE=unspecified
    fi

    (( N = 10#${CLIENT_NAME::5} ))
    n=0
    while read line; do
        ((n++))
        if [[ ${n} -eq ${N} ]]; then
            if [[ "${line::1}" == 'R' ]]; then
                VALID_CERT=no
            else
                VALID_CERT=yes
            fi
            break
        fi
    done <"${EASYRSA}/pki/index.txt"

    echo "${CLIENT_NAME}:
    Server side config: ${CLIENT_CONFIG}
    Enabled: ${ENABLED}
    Valid cert: ${VALID_CERT}
    Type: ${CLIENT_TYPE}"
    if [[ "${CLIENT_TYPE}" == 'router' || "${CLIENT_TYPE}" == 'mixed' ]]; then
        echo "    Internal subnets: ${SUBNET}"
    fi
    if [[ "${CLIENT_TYPE}" == 'user' || "${CLIENT_TYPE}" == 'mixed' ]]; then
        echo "    Users shared config: ${USERS_CONF}"
    fi
}


add_client() {
    local HOST_NAME FLNUMBER NUMBER USER CLIENT_CONFIG_NAME DEC_IP srv TMP_USER_DIR
    HOST_NAME=$1
    printf -v FLNUMBER '%05d' $(( 16#$(< "${EASYRSA}/pki/serial") ))
    (( NUMBER = 10#${FLNUMBER} ))
    USER="${FLNUMBER}-${HOST_NAME}"
    case "${CLIENT_OS}" in
        windows)
            CLIENT_CONFIG_NAME="${USER}.ovpn"
            eval "read -rd '' OS_SPECIFIC_OPTIONS <<EOFOSSO${BR}${WIN_SPECIFIC_OPTIONS}${BR}${BR}#${NIX_SPECIFIC_OPTIONS//${BR}/${BR}#}${BR}${BR}EOFOSSO"
            ;;
        *)
            CLIENT_CONFIG_NAME="${USER}.conf"
            eval "read -rd '' OS_SPECIFIC_OPTIONS <<EOFOSSO${BR}${NIX_SPECIFIC_OPTIONS}${BR}${BR}#${WIN_SPECIFIC_OPTIONS//${BR}/${BR}#}${BR}${BR}EOFOSSO"
    esac

    cd "${EASYRSA}"

    ./easyrsa --batch --req-cn="${USER}" gen-req "${USER}" nopass &>"${DESCRIPTOR}" || quit 1 "Easyrsa error: $?"
    ./easyrsa --batch --req-cn="${USER}" sign-req client "${USER}" &>"${DESCRIPTOR}" || quit 1 "Easyrsa error: $?"

    # Change CN in Authority Key Identifier DirName for compatibility with Netcomm routers openvpn interface
    sed -i -e "s/\/CN=server\//\/CN=${USER}\//" -e "s/\/CN=server$/\/CN=${USER}/" "${EASYRSA}/pki/issued/${USER}.crt"

    # Calculate client OVPN IP and NETMASK
    srv=$(exec -c grep -m1 '^server ' "${SERVER_CONF}")
    srv=${srv#server }
    srv=${srv% nopool*}
    ip2dec -v DEC_IP ${srv%% *}
    dec2ip -v CLIENT_OVPN_IP $((DEC_IP+NUMBER))
    NETMASK=${srv#* }

    ## Number for ethN and tunN, first host cert will have N=0, 2nd - N=1 etc.
    N=$(ls -1 "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}" 2>/dev/null | wc -l)

    # Create symlinks if possible, copy otherwise
    if ln -s "${EASYRSA}/pki/issued/${USER}.crt" "${CLIENT_KEYS_DIR}" >/dev/null; then
        ln -s "${EASYRSA}/pki/private/${USER}.key" "${CLIENT_KEYS_DIR}"
    else
        cp "${EASYRSA}/pki/issued/${USER}.crt" "${EASYRSA}/pki/private/${USER}.key" "${CLIENT_KEYS_DIR}"
    fi
    echo "ifconfig-push ${CLIENT_OVPN_IP} ${NETMASK}" >"${CLIENT_CONFIG_DIR}/${USER}"

    case "${CLIENT_TYPE}" in
        user)
            echo "config ${USERS_CONF_IN_CHROOT}" >>"${CLIENT_CONFIG_DIR}/${USER}"
        ;;
        router)
            CLIENT_SUBNET_BEHIND_IP=${CLIENT_SUBNET_BEHIND%%/*}
            cidr2mask -v CLIENT_SUBNET_BEHIND_MASK ${CLIENT_SUBNET_BEHIND#*/}
            echo "iroute ${CLIENT_SUBNET_BEHIND_IP} ${CLIENT_SUBNET_BEHIND_MASK}" >>"${CLIENT_CONFIG_DIR}/${USER}"
            ROUTER_CONF_STR='# On config creation time vpn-server used the following internal subnet for this client:'
            ROUTER_CONF_STR+="# ${CLIENT_SUBNET_BEHIND}"
            ROUTER_CONF_STR+='# It should match real internal subnet if you want allow vpn-users access it.'
            ROUTER_CONF_STR+='# Forwarding should be enabled for vpn<->subnet interfaces.'
        ;;
    esac

    if [[ ${D} ]]; then
        disable_client "${USER}"
    fi

    chown :"${OPENVPN_GROUP}" "${CLIENT_CONFIG_DIR}/${USER}"
    chmod 640 "${CLIENT_CONFIG_DIR}/${USER}"

    # chown :${OPENVPN_GROUP} "${EASYRSA}/pki/index.txt"
    # chmod 640 "${EASYRSA}/pki/index.txt"
    # chmod og+x "${EASYRSA}/pki"{,/issued,/private}

    # cp "${EASYRSA}/pki/issued/${USER}.crt" "${EASYRSA}/pki/private/${USER}.key" "${KEYS_DIR}/ca.crt" "${KEYS_DIR}/ta.key" temp
    mkdir -p "${CLIENT_PACKS_DIR}/${HOST_NAME}"

    # Write client config
    eval "read -rd '' CLIENT_CONFIG <<EOF${BR}${CLIENT_CONFIG_TEMPLATE}${BR}EOF"
    echo "${CLIENT_CONFIG}" >"${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}"
    # (set -o posix; set) >&2

    # .zip pack beside all-in-one config
    # Include:
    #     ${USER}.tgz with ca.crt ${USER}.key ${USER}.crt
    #     ta.key
    #     ${USER} all-in-one conf
    TMP_USER_DIR="/tmp/openvpn-manage/${USER}"
    mkdir -p "${TMP_USER_DIR}"
    tar --transform 's/.*\///g' -zchf "${TMP_USER_DIR}/${USER}.tgz" "./pki/private/${USER}.key" "./pki/issued/${USER}.crt" ./pki/ca.crt &>"${DESCRIPTOR}"
    cp -l ./pki/ta.key "${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}" "${TMP_USER_DIR}/" &>"${DESCRIPTOR}" || \
        cp ./pki/ta.key "${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}" "${TMP_USER_DIR}/" &>"${DESCRIPTOR}"
    zip -rjD "${CLIENT_PACKS_DIR}/${HOST_NAME}/${USER}.zip" "${TMP_USER_DIR}/" &>"${DESCRIPTOR}"
    rm "${TMP_USER_DIR}/"{"${USER}.tgz",ta.key,"${CLIENT_CONFIG_NAME}"} &>"${DESCRIPTOR}" && rm -r "${TMP_USER_DIR}/" &>"${DESCRIPTOR}"

    [[ ${DESCRIPTOR} == /dev/null ]] || echo "${BR}${BR}"
    echo "${USER}: config created:${BR}${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}"
    cd - >/dev/null
}


create_host() {
    local HOST_NAME COUNT INCSUB
    HOST_NAME=$1
    [[ $2 ]] && COUNT=$2 || COUNT=1
    if (( COUNT <= 0 )); then
        quit 1 "Invalid COUNT: ${COUNT}"
    fi

    for ((n=1;n<=COUNT;++n)); do
        INCSUB=no  # Is subnet was incremented?
        if [[ "${CLIENT_TYPE}" == router ]]; then
            if [[ -z "${CLIENT_SUBNET_BEHIND}" ]]; then
                # Increment last saved subnet
                if [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]]; then
                    increment_subnet -v CLIENT_SUBNET_BEHIND "$(< "${LAST_IROUTE_SUBNET_FILE}")"
                else
                    CLIENT_SUBNET_BEHIND=${INITIAL_IROUTE_SUBNET}
                fi
                INCSUB=yes
            fi
            if [[ -z "${S}" ]]; then  # If not specified in command line
                validate_ip4cidr "${CLIENT_SUBNET_BEHIND}" || quit 1 "Invalid subnet: ${CLIENT_SUBNET_BEHIND}"
            fi
        fi

        add_client "${HOST_NAME}"

        if [[ $? -eq 0 && "${INCSUB}" == yes ]]; then
            [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]] && mv "${LAST_IROUTE_SUBNET_FILE}"{,.old}
            echo "${CLIENT_SUBNET_BEHIND}" >"${LAST_IROUTE_SUBNET_FILE}"
            echo "Note: LAST_IROUTE_SUBNET was incremented to ${CLIENT_SUBNET_BEHIND}" >&2
        fi
        if [[ "${CLIENT_TYPE}" == router ]]; then
            echo "Router internal subnet set to ${CLIENT_SUBNET_BEHIND}"
        fi
        echo
    done

    zip --exclude \*.zip -rjD "${CLIENT_PACKS_DIR}/${HOST_NAME}.zip" "${CLIENT_PACKS_DIR}/${HOST_NAME}/" >/dev/null
    echo
    echo "Host pack with client configs created:${BR}${CLIENT_PACKS_DIR}/${HOST_NAME}.zip"
}


find_client_names() {
    # Return array of client names for specified host_name
    local _var _res _host_name _filename
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi
    _res=()
    _host_name=$1
    for _filename in "${CLIENT_PACKS_DIR}/${_host_name}/"*.{ovpn,conf}; do
        _filename=${_filename##*/}
        _filename=${_filename%.ovpn}
        _filename=${_filename%.conf}
        [[ "${_filename}" == '*' ]] && continue
        _res+=("${_filename}")
    done

    if [[ ${_var} ]]; then eval "${_var}=(\${_res[@]})"; else echo "${_res[@]}"; fi
}

BR=$'\n'

read -rd '' USAGE <<'EOF'
Usage:
    openvpn-manage ACTION { PARAMS } [ OPTIONS ]
    ACTION := { usage | help | create | append | enable | disable | revoke | list | show }
    OPTIONS := { -f CONF | -t CLIENT_TYPE | -s IP/CIDR | -c COUNT | -o CLIENT_OS | -e | -d | -v }
    CLIENT_TYPE := { user | router }
    CLIENT_OS := { windows | nix }

    openvpn-manage { create | append } HOST_NAME [ OPTIONS ]

    openvpn-manage { enable | disable | revoke } { host HOST_NAME | client CLIENT_NAME }

    openvpn-manage list { host[s] | client[s] } [ HOST_NAME ] { -t CLIENT_TYPE | -s CLIENT_SUBNET_BEHIND | -e | -d }

    openvpn-manage show { host HOST_NAME | client CLIENT_NAME }
EOF

read -rd '' HELP <<EOF
${USAGE}

Description:
    "host" is the name of specific host (specific host can have several clients/certs).
    "client" is specific vpn-client/cert for the host.

Actions:
    create host HOST_NAME
    append client HOST_NAME
        Used for create/append clients to HOST_NAME.
        Difference is:
        validation - you can't create host if HOST_NAME already exist and you can't
            append clients to non-existent host.
        subnet applying for type router - for "append" if -s not specified additional clients of
            the host will have the same subnet as first available iroute option
            in first available client config.

    enable, disable, revoke
        You can enable/disable/revoke specific client (client CLIENT_NAME) or all clients
        (host HOST_NAME) of the host.
        Enable and disable just delete/add 'disable' line to client config, so client can't
        connect. Host/client can be enabled/disabled any time.
        revoke adds client[s] cert[s] to revocation list, so it could be treated as
        persistent client deactivation.
        Note: revoked cert still can be unrevoked manually, but it's not supported
        by openvpn-manage.

    list
        List hosts or clients depends on filter options.
        For HOST_NAME grep standard regexp's supported.
        Examples:
            List all hosts:
                list hosts
            List all routers clients:
                list clients -t router
            List enabled clients of specific host with specified internal subnet:
                list clients HOST_NAME -e -s 10.10.0.8/29

Options:
    -f CONF
        Configuration file of openvpn-manage
        Default: /etc/openvpn/server/scripts/openvpn-manage.conf

    -t CLIENT_TYPE
        Could be "user" (default) or "router". Difference is client config options.
        User config contain push "route ..." to the routers internal subnets.
        Router config contain iroute to internal subnet behind it.

    -s CLIENT_SUBNET_BEHIND
        Format: IP/CIDR. Subnet behind the router. Valid only if CLIENT_TYPE is "router".
        If no subnet specified subnet will be incremented from the last saved subnet.
        Subnet will be saved to LAST_IROUTE_SUBNET_FILE. If no file exist
        INITIAL_IROUTE_SUBNET will be used and then saved to LAST_IROUTE_SUBNET_FILE.
        Subnet will be saved only if -s option omitted, so manually specified subnet
        will not be saved in LAST_IROUTE_SUBNET_FILE. It's allow manually specify
        subnet without interrupt existing subnet chain.

    -c COUNT
        Default is 1. Allow to create COUNT clients/certs for the host with single
        command. Additional host clients/certs could be added via action "append"
        next time.

    -e, -d
        List enabled/disabled only.

    -v
        Verbose output.
EOF


# Main case: Parse positional arguments
case "$1" in
    ''|usage) quit 255 "${USAGE}"; ;;

    help) quit 255 "${HELP}"; ;;

    *)  # Parse args, verify, apply defaults.
        # Really not for all actions root required, but to be sure...
        # ((UID)) && quit 2 'Root privileges required'

        [[ $2 ]] || quit 1 "Action requires parameter!"
        unset HELP USAGE

        ## Defaults
        DESCRIPTOR=/dev/null  # Default if no -v option specified
        CONF='/etc/openvpn/server/scripts/openvpn-manage.conf'

        # Options below can be overwrited in CONF file
        CA_PASS=no  # 'yes' if CA is password protected
        SERVER_DIR='/etc/openvpn/server'
        KEYS_DIR="${SERVER_DIR}/keys"
        CLIENT_KEYS_DIR="${SERVER_DIR}/client-keys"
        CLIENT_PACKS_DIR="${SERVER_DIR}/client-packs"
        CLIENT_CONFIG_DIR="${SERVER_DIR}/client-configs"
        USERS_CONF="${SERVER_DIR}/users-config"
        SERVER_CONF="${SERVER_DIR}/server.conf"  # If tcp and udp servers subnet are the same, any config is fine here
        EASYRSA='/etc/openvpn/easy-rsa/easyrsa3'
        CLIENT_OS_DEFAULT='nix'  # 'nix' for Unix-based OS, 'windows' for Windows
        OPENVPN_USER=openvpn
        OPENVPN_GROUP=openvpn
        INITIAL_IROUTE_SUBNET='10.10.0.0/29'
        LAST_IROUTE_SUBNET_FILE="${SERVER_DIR}/last_iroute_subnet"
        HOST_NAME_ALLOWED_REGEX='^[A-Za-z0-9_-]+$'
        ALLOW_DIFFERENT_CLIENT_TYPES_FOR_HOST=no
        ## END Defaults

        ## Parse options
        # Calculate first option position
        for ((i=1;i<=$#;++i)); do
            if [[ "${!i::1}" == '-' ]]; then
                OPTIND=$i
                break
            fi
        done
        while getopts ":vedt:o:s:c:f:" OPT; do
            [[ "${OPTARG::1}" = '-' ]] && quit 1 "Option argument can not start with '-'"
            case "$OPT" in
                v) DESCRIPTOR=/dev/stdout; V='-v'; ;;
                e) ENABLED=yes; E='-e'; ;;
                d) ENABLED=no; D='-d'; ;;
                t) CLIENT_TYPE=${OPTARG}; T='-t'; ;;
                o) CLIENT_OS=${OPTARG}; O='-o';
                    case "${CLIENT_OS}" in
                        linux|mac|bsd) CLIENT_OS=nix; ;;
                        windows|nix) ;;
                        *) quit 1 "Invalid OS: ${CLIENT_OS}${BR}"'Have to be "windows" or "nix" (for Linux/Mac/BSD/etc). "linux", "mac", "bsd" translated to "nix".'
                    esac
                    ;;
                s) CLIENT_SUBNET_BEHIND=${OPTARG}; S='-s';
                    validate_ip4cidr "${CLIENT_SUBNET_BEHIND}" || quit 1 "Invalid subnet: ${CLIENT_SUBNET_BEHIND}"
                    ;;
                c) COUNT=${OPTARG}; C='-c'; ;;
                f) CONF=${OPTARG}; F='-f'; ;;
                :) quit 1 "Option -$OPTARG requires an argument"; ;;
                *) quit 1 "Invalid option: -$OPTARG"; ;;
            esac
        done
        # OPTIND=1

        # Import configuration file
        . "${CONF}"
        (($?==0)) || quit 1 "Failed to import configuration file: ${CONF}"
        # echo "${CLIENT_CONFIG_TEMPLATE}" >&2

        CHROOT=$(exec -c grep -m1 '^chroot ' "${SERVER_CONF}")
        CHROOT=${CHROOT#chroot }
        if [[ -n "${CHROOT}" && "${CHROOT}" != '/' ]]; then
            USERS_CONF_IN_CHROOT=${USERS_CONF##*/}  # E.g. users-config
        else
            USERS_CONF_IN_CHROOT=${USERS_CONF}
        fi

        # Verification of config options
        [[ -d "${CHROOT}" ]] || quit 1 "Chroot server dir have to exist for current configuration: ${CHROOT}"
        [[ -d "${SERVER_DIR}" ]] || quit 1 "Server dir does not exist: ${SERVER_DIR}"
        [[ -d "${KEYS_DIR}" ]] || quit 1 "Keys dir does not exist: ${KEYS_DIR}"
        [[ -d "${CLIENT_KEYS_DIR}" ]] || quit 1 "Clients keys dir does not exist: ${CLIENT_KEYS_DIR}"
        [[ -d "${CLIENT_PACKS_DIR}" ]] || quit 1 "Clients packages dir dir does not exist: ${CLIENT_PACKS_DIR}"
        [[ -d "${CLIENT_CONFIG_DIR}" ]] || quit 1 "Clients config dir dir does not exist: ${CLIENT_CONFIG_DIR}"
        [[ -f "${USERS_CONF}" ]] || quit 1 "Users shared config file does not exist: ${USERS_CONF}"
        [[ -f "${SERVER_CONF}" ]] || quit 1 "OpenVPN server config file does not exist: ${SERVER_CONF}"
        [[ -d "${EASYRSA}" ]] || quit 1 "EASYRSA dir does not exist: ${EASYRSA}"
        [[ -f "${EASYRSA}/pki/crl.pem" ]] || quit 1 "Certificate revocation list file does not exist: ${EASYRSA}/pki/crl.pem"
        getent passwd "${OPENVPN_USER}" &>/dev/null || quit 1 "No such user: ${OPENVPN_USER}"
        getent group "${OPENVPN_GROUP}" &>/dev/null || quit 1 "No such group: ${OPENVPN_GROUP}"


        [[ -z ${CLIENT_OS} ]] && CLIENT_OS=${CLIENT_OS_DEFAULT}

        if [[ -n $E && -n $D ]]; then
            quit 1 "Options -e and -d can not be specified simultaneously!"
        fi

        case "${CLIENT_TYPE}" in
            '') CLIENT_TYPE=user; ;;
            user|router) ;;
            *) quit 1 "Invalid argument for -t option: ${CLIENT_TYPE}"; ;;
        esac

        if [[ -n "${S}" && "${CLIENT_TYPE}" != router ]]; then
            quit 1 "Subnet can be specified for type \"router\" only"
        fi

        case "${COUNT}" in
            '') COUNT=1; ;;
            *[^0-9]*) quit 1 "Invalid COUNT: ${COUNT}"; ;;
        esac
        ;;&

    create)
        HOST_NAME=$2
        [[ ${HOST_NAME} ]] || quit 1 "You have to specify HOST_NAME"
        validate_host_name "${HOST_NAME}"
        if [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
            quit 1 "Host already exist: ${HOST_NAME}${BR}Use \"append\" to append clients to existing host."
        fi
        ;;&

    append)
        HOST_NAME=$2
        [[ ${HOST_NAME} ]] || quit 1 "You have to specify HOST_NAME"
        validate_host_name "${HOST_NAME}"
        if ! [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
            quit 1 "Host does not exist: ${HOST_NAME}${BR}Use 'create' to create new host."
        fi

        for i in "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}"; do FIRST_CLIENT_CONFIG_FILE=$i; break; done
        if grep -q '^iroute ' "${FIRST_CLIENT_CONFIG_FILE}"; then
            # Use the same client type as other clients has
            CLIENT_TYPE_PREVIOUS=router
        else
            CLIENT_TYPE_PREVIOUS=user
        fi
        if [[ "${CLIENT_TYPE_PREVIOUS}" != "${CLIENT_TYPE}" ]]; then
            if [[ "${ALLOW_DIFFERENT_CLIENT_TYPES_FOR_HOST}" == yes ]]; then
                if [[ ${T} ]]; then  # Specified in command line explicitly
                    [[ ${V} ]] && echo "Warning: Client type specified in command line doesn't match the type of previous clients for this host!" &>"${DESCRIPTOR}"
                else
                    CLIENT_TYPE=${CLIENT_TYPE_PREVIOUS}
                fi
            else
                [[ $T ]] && quit 1 "Client type specified in command line doesn't match the type of previous clients for this host!${BR}Remove it or specify proper type."
                CLIENT_TYPE=${CLIENT_TYPE_PREVIOUS}
            fi
        fi
        if [[ "${CLIENT_TYPE}" == router && -z "${S}" ]]; then
            populate_subnet_var "${HOST_NAME}"
        fi

        # Reuse previous CLIENT_OS if commandline option '-o' ommited
        for i in "${CLIENT_PACKS_DIR}/${HOST_NAME}/"*[np][fn]; do FIRST_EXT=${i##*.}; break; done
        if [[ -z "$O" ]]; then
            if [[ "${FIRST_EXT}" == 'ovpn' ]]; then
                CLIENT_OS=windows
            else
                CLIENT_OS=nix
            fi
        fi
        ;;&

    create|append)
        [[ -z ${CLIENT_CONFIG_TEMPLATE} ]] && quit 1 'CLIENT_CONFIG_TEMPLATE variable required, you have to set it in configuration file.'
        create_host "${HOST_NAME}" "${COUNT}"
        ;;

    enable|disable|revoke|update|show)
        case "$2" in
            client)
                CLIENT_NAME=$3
                [[ ${CLIENT_NAME} ]] || quit 1 "You have to specify CLIENT_NAME"
                validate_client_name "${CLIENT_NAME}"
                if ! [[ -f "${CLIENT_CONFIG_DIR}/${CLIENT_NAME}" ]]; then
                    quit 1 "No such client or client config is absent: ${CLIENT_NAME}"
                fi
                ;;
            host)
                HOST_NAME=$3
                [[ ${HOST_NAME} ]] || quit 1 "You have to specify HOST_NAME"
                validate_host_name "${HOST_NAME}"
                if ! [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
                    quit 1 "No such host: ${HOST_NAME}"
                fi
                ;;
            *) quit 1 "Invalid parameter: $2"
        esac
        ;;&

    enable)
        case "$2" in
            client)
                enable_client "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do enable_client "${cn}"; done
                echo "${BR}All clients of ${HOST_NAME} was enabled"
                ;;
        esac
        ;;

    disable)
        case "$2" in
            client)
                disable_client "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do disable_client "${cn}"; done
                echo "${BR}All clients of ${HOST_NAME} was disabled"
                ;;
        esac
        ;;

    revoke)
        cd "${EASYRSA}"
        case "$2" in
            client)
                revoke_cert "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do revoke_cert "${cn}"; done
                echo "${BR}All certs of ${HOST_NAME} was revoked"
                ;;
        esac
        ./easyrsa --batch gen-crl &>"${DESCRIPTOR}" && echo "Revocation list was updated" \
                                                || quit 1 "Failed to update revocation list!"
        chown :"${OPENVPN_GROUP}" "${EASYRSA}/pki/crl.pem"
        chmod 440 "${EASYRSA}/pki/crl.pem"
        if [[ -d /etc/openvpn/chroot ]]; then
            rm -f /etc/openvpn/chroot/crl.pem  # Workaround for CentOS which ignore -f option for cp
            cp -pfT "${EASYRSA}/pki/crl.pem" /etc/openvpn/chroot/crl.pem
        fi
        # chown :${OPENVPN_GROUP} "${EASYRSA}/pki/index.txt"
        # chmod 640 "${EASYRSA}/pki/index.txt"
        # chmod g+x "${EASYRSA}/pki"
        cd - >/dev/null
        ;;

    update)  # Update type and/or subnet
        case "$2" in
            client)
                update_client "${CLIENT_NAME}"
                ;;
            host)
                # quit 254 "Update all host clients feature does not implemented yet. Use it with single client."
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do update_client "${cn}"; done
                echo "${BR}All clients of ${HOST_NAME} was updated"
                ;;
        esac
        ;;

    list)  # TODO: finish
        case "$2" in
            clients|client)
                OUT=$(ls -1 "${CLIENT_CONFIG_DIR}" | grep -v '^DEFAULT$')  # All clients/certs
                if [[ -z $3 ]]; then
                    [[ ${OUT} ]] && echo "${OUT}" || quit 1 "No clients match!"
                    exit 0
                elif [[ "${3::1}" != '-' ]]; then
                    # Filter by HOST_NAME
                    HOST_NAME=$3
                    OUT=$(exec -c grep "^[[:digit:]]*-${HOST_NAME}$" <<<"${OUT}")
                    [[ ${OUT} ]] || quit 1 "No clients match!"
                    # [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]] || quit 1 "No such host: ${HOST_NAME}"
                    # ls -1 "${CLIENT_CONFIG_DIR}" | grep "^[[:digit:]]*-${HOST_NAME}$"
                    # find "${CLIENT_CONFIG_DIR}" -maxdepth 1 -mindepth 1 -type f -name "[0-9]+-$3" -printf "%f\n"  | awk -F / '{print $NF}' | cut -d- -f2- | sort -u
                fi

                # Filter by options
                if [[ $T ]]; then
                    case "${CLIENT_TYPE}" in
                        router)
                            OUT=$(while read client; do
                                    grep -q '^iroute ' "${CLIENT_CONFIG_DIR}/${client}" && echo "${client}";
                                done <<<"${OUT}")
                            ;;
                        user)
                            OUT=$(while read client; do
                                    grep -q '^iroute ' "${CLIENT_CONFIG_DIR}/${client}" || echo "${client}";
                                done <<<"${OUT}")
                            ;;
                    esac
                fi
                if [[ $D ]]; then
                    OUT=$(while read client; do
                            grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${client}" && echo "${client}";
                        done <<<"${OUT}")
                elif [[ $E ]]; then
                    OUT=$(while read client; do
                            grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${client}" || echo "${client}";
                        done <<<"${OUT}")
                fi
                if [[ $S ]]; then
                    IP=${CLIENT_SUBNET_BEHIND%%/*}
                    cidr2mask -v MASK ${CLIENT_SUBNET_BEHIND#*/}
                    OUT=$(while read client; do
                            grep -q "^iroute ${IP} ${MASK}" "${CLIENT_CONFIG_DIR}/${client}" && echo "${client}";
                        done <<<"${OUT}")
                fi
                # if [[ $O ]]; then
                #     # Can be manually changed by user, so skip implementing this filter.
                # fi

                [[ ${OUT} ]] && echo "${OUT}" || quit 1 "No clients match!"
                ;;
            hosts|host)
                OUT=$(ls -1 "${CLIENT_CONFIG_DIR}" | grep -v '^DEFAULT$' | cut -d- -f2- | sort -u)  # All hosts
                if [[ -z $3 ]]; then
                    [[ ${OUT} ]] && echo "${OUT}" || quit 1 "No hosts match!"
                    exit 0
                elif [[ "${3::1}" != '-' ]]; then
                    # Filter by HOST_NAME
                    HOST_NAME=$3
                    OUT=$(exec -c grep "^${HOST_NAME}$" <<<"${OUT}")
                    [[ ${OUT} ]] || quit 1 "No hosts match!"
                fi

                # Filter by options
                if [[ $T ]]; then
                    case "${CLIENT_TYPE}" in
                        router)
                            OUT=$(while read HOST_NAME; do
                                    grep -q '^iroute ' "$(ls -1 "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}" | head -1)" \
                                    && echo "${HOST_NAME}";
                                done <<<"${OUT}")
                            ;;
                        user)
                            OUT=$(while read HOST_NAME; do
                                    grep -q '^iroute ' "$(ls -1 "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}" | head -1)" \
                                    || echo "${HOST_NAME}";
                                done <<<"${OUT}")
                            ;;
                    esac
                fi
                if [[ $D ]]; then
                    # The host treated as disabled if all its clients disabled
                    quit 254 "-d filter for hosts is not implemented yet"
                    # OUT=$(while read HOST_NAME; do
                    #         grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${client}" && echo "${HOST_NAME}";
                    #     done <<<"${OUT}")
                elif [[ $E ]]; then
                    # The host treated as enabled if at least one of its clients enabled
                    quit 254 "-e filter for hosts is not implemented yet"
                fi
                if [[ $S ]]; then
                    quit 254 "-s filter for hosts is not implemented yet"
                fi

                [[ ${OUT} ]] && echo "${OUT}" || quit 1 "No hosts match!"
                ;;
            *) quit 1 "Invalid parameter: $2"
        esac
        ;;

    show)
        case "$2" in
            client)
                show_client "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do show_client "${cn}"; echo; done
                ;;
        esac
        ;;

    *)                                                                                                                                                                                                                 EE=${BR}${BR}'But don'$'\'''t be upset! Pet the croco and go ahead to eat some cookies!'$'\n'; KOTEHOK=$'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x2e\x2e\x2d\x2d\x27\x27\x60\x60\x2d\x2d\x2d\x2e\x2e\x2e\x2e\x5f\x5f\x5f\x20\x20\x20\x5f\x2e\x2e\x2e\x5f\x20\x20\x20\x20\x5f\x5f\x0a\x2f\x2f\x2f\x20\x2f\x2f\x5f\x2e\x2d\x27\x20\x20\x20\x20\x2e\x2d\x2f\x22\x3b\x20\x20\x60\x20\x20\x20\x20\x20\x20\x20\x20\x60\x60\x3c\x2e\x5f\x20\x20\x60\x60\x2e\x27\x27\x5f\x20\x60\x2e\x20\x2f\x20\x2f\x2f\x20\x2f\x0a\x2f\x2f\x2f\x5f\x2e\x2d\x27\x20\x5f\x2e\x2e\x2d\x2d\x2e\x27\x5f\x20\x20\x20\x20\x5c\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x60\x28\x20\x29\x20\x29\x20\x2f\x2f\x20\x2f\x2f\x0a\x2f\x20\x28\x5f\x2e\x2e\x2d\x27\x20\x2f\x2f\x20\x28\x3c\x20\x5f\x20\x20\x20\x20\x20\x3b\x5f\x2e\x2e\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x3b\x20\x60\x27\x20\x2f\x20\x2f\x2f\x2f\x0a\x2f\x20\x2f\x2f\x20\x2f\x2f\x20\x2f\x2f\x20\x20\x60\x2d\x2e\x5f\x2c\x5f\x29\x27\x20\x2f\x2f\x20\x2f\x20\x60\x60\x2d\x2d\x2e\x2e\x2e\x5f\x5f\x5f\x5f\x2e\x2e\x2d\x27\x20\x2f\x2f\x2f\x20\x2f\x20\x2f\x2f\x27\x0a'; HEKOTEHOK=$'\x20\x20\x20\x20\x20\x20\x5f\x3d\x2c\x5f\x0a\x20\x20\x20\x6f\x5f\x2f\x36\x20\x2f\x23\x20\x20\x20\x5c\x5f\x5f\x20\x7c\x23\x23\x2f\x0a\x20\x20\x20\x20\x3d\x27\x7c\x2d\x2d\x20\x20\x20\x20\x20\x20\x2f\x20\x20\x20\x23\x27\x2d\x2e\x0a\x20\x20\x20\x20\x20\x20\x5c\x23\x7c\x5f\x20\x20\x20\x5f\x27\x2d\x2e\x20\x2f\x0a\x20\x20\x20\x20\x20\x20\x20\x7c\x2f\x20\x5c\x5f\x28\x20\x23\x20\x7c\x22\x0a\x20\x20\x20\x20\x20\x20\x43\x2f\x20\x2c\x2d\x2d\x5f\x5f\x5f\x2f\x0a'; if ((1$(exec -c date +%N)%2)); then EE+=${KOTEHOK}; else EE+=${HEKOTEHOK}; fi  # Easter egg =)
        quit 1 "This action is not implemented yet.${EE}"
        ;;
esac

exit 0

EOF_OPENVPN_MANAGE
echo "${OPENVPN_MANAGE}" >'/etc/openvpn/server/scripts/openvpn-manage'

chmod +x /etc/openvpn/server/scripts/openvpn-manage
# ln -s /etc/openvpn/server/scripts/openvpn-manage /usr/local/bin/  # Already done

## Preparations for learn-address script (for dual tcp/udp server in chrooted environment)
cd /etc/openvpn/chroot
OPENVPN_GID=$(getent group openvpn | cut -d: -f3)
cat >etc/busybox.conf <<EOFBUSYBOXCONF
[SUID]
# ${OPENVPN_GID} is openvpn group number
iproute = sx- 0.${OPENVPN_GID}
sh = xx- 0.${OPENVPN_GID}
EOFBUSYBOXCONF
wget -nv https://busybox.net/downloads/binaries/1.27.1-i686/busybox_ASH -O bin/sh
wget -nv https://busybox.net/downloads/binaries/1.27.1-i686/busybox_IPROUTE -O bin/iproute
chown root:root etc/busybox.conf bin/iproute
chown root:openvpn bin/sh
chmod 640 etc/busybox.conf
chmod 4755 bin/iproute
chmod 750 bin/sh

## Create suitable /etc/openvpn/easy-rsa/easyrsa3/vars
cp /etc/openvpn/easy-rsa/easyrsa3/vars{.example,}
sed -i \
    -e 's|^#set_var\s\+EASYRSA_TEMP_FILE\s.*|set_var EASYRSA_TEMP_FILE "/dev/shm/extensions.temp"|' \
    -e 's|^#set_var\s\+EASYRSA_CA_EXPIRE\s.*|set_var EASYRSA_CA_EXPIRE 7300|' \
    -e 's|^#set_var\s\+EASYRSA_CERT_EXPIRE\s.*|set_var EASYRSA_CERT_EXPIRE 7300|' \
    -e 's|^#set_var\s\+EASYRSA_CRL_DAYS\s.*|set_var EASYRSA_CRL_DAYS 7300|' \
    -e 's|^#set_var\s\+EASYRSA_REQ_CN\s.*|set_var EASYRSA_REQ_CN "server"|' \
    -e 's|^#set_var\s\+EASYRSA_BATCH\s.*|set_var EASYRSA_BATCH "neveraskmehoney"|' \
    /etc/openvpn/easy-rsa/easyrsa3/vars

## Fix CRL issue when in chroot
# sed -i \
#     -e 's|^crl_dir\s*=\s*$dir|crl_dir\t = /etc/openvpn/chroot|' \
#     -e 's|^crl\s*=\s*$dir|crl\t = /etc/openvpn/chroot|' \
#     /etc/openvpn/easy-rsa/easyrsa3/openssl-1.0.cnf


## Create suitable /etc/openvpn/server/users-config (Used for selectable forwarding)
echo 'push "redirect-gateway def1"
push "dhcp-option DNS 8.8.8.8"
push "dhcp-option DNS 208.67.222.222"
' >/etc/openvpn/server/users-config


## Create configs
# /etc/openvpn/chroot/scripts/learn-address
read -rd '' LEARN_ADDRESS <<'EOF_LEARN_ADDRESS'
#!/bin/sh

##
# This script allows to share the same VPN subnet between TCP and UDP openvpn server
# Sudoers have to be setup to allow openvpn user to change routing table.
#
# This file created to work in chrooted environment using busybox
##


# Operation: "add", "update", or "delete" based on whether or not the address is being added to, modified, or deleted from OpenVPN's internal routing table.
MODE=$1

# Address: The address being learned or unlearned.
# This can be an IPv4 address such as "198.162.10.14",
# an IPv4 subnet such as "198.162.10.0/24",
# or an ethernet MAC address (when --dev tap is being used) such as "00:FF:01:02:03:04".
IP=$2

# Common Name: The common name on the certificate associated with the client linked to this address.
# Only present for "add" or "update" operations, not "delete".
# CN=$3

# Some environmental variables also available, e.g.: dev

case "${MODE}" in
    add|update)
        # exec -c sudo ip route add ${IP} dev ${dev} proto static scope link
        echo "Learn: iproute del ${IP}"
        iproute del ${IP}
        echo "Learn: iproute add ${IP} dev ${dev} proto static scope link"
        iproute add ${IP} dev ${dev} proto static scope link
        ;;
esac
EOF_LEARN_ADDRESS
echo "${LEARN_ADDRESS}" >'/etc/openvpn/chroot/scripts/learn-address'

# /etc/openvpn/server/scripts/openvpn-manage.conf  # Change SERVER_PUBLIC_IP to your server public IP or domain
read -rd '' OPENVPN_MANAGE_CONF <<EOF_OPENVPN_MANAGE_CONF
##
# Configuration file for openvpn-manage.
# Bash syntax required
# Easyrsa 'vars' file have to be properly setup before
##


## Usually you don't need to change these options
# SERVER_DIR='/etc/openvpn/server'
# KEYS_DIR="\${SERVER_DIR}/keys"
# CLIENT_KEYS_DIR="\${SERVER_DIR}/client-keys"
# CLIENT_PACKS_DIR="\${SERVER_DIR}/client-packs"
# CLIENT_CONFIG_DIR="\${SERVER_DIR}/client-configs"
CLIENT_CONFIG_DIR='/etc/openvpn/chroot/ccd'
# USERS_CONF="\${SERVER_DIR}/users-config"
SERVER_CONF='/etc/openvpn/udp.server.conf'  # If tcp and udp servers subnet are the same, any config is fine here
# EASYRSA='/etc/openvpn/easy-rsa/easyrsa3'
CLIENT_OS_DEFAULT='windows'  # 'nix' for Unix-based OS, 'windows' for Windows
# OPENVPN_USER=openvpn
# OPENVPN_GROUP=openvpn

# CA_PASS='no'  # 'yes' if CA is password protected

## Example of variables which can be used in client config options
## You can also use custom variables specified in this file
# CLIENT_CONFIG_DIR=/etc/openvpn/chroot/ccd
# CLIENT_CONFIG_NAME=00008-win-test.conf
# CLIENT_PACKS_DIR=/etc/openvpn/server/client-packs
# CLIENT_KEYS_DIR=/etc/openvpn/server/client-keys
# CLIENT_OS=nix
# CLIENT_OVPN_IP=172.31.240.8
# CLIENT_TYPE=user
# EASYRSA=/etc/openvpn/easy-rsa/easyrsa3
# FIRST_CLIENT_CONFIG_FILE=/etc/openvpn/chroot/ccd/00006-win-test
# FLNUMBER=00008
# HOST_NAME=win-test
# HOST_NAME_ALLOWED_REGEX='^[A-Za-z0-9_-]+\$'
# INITIAL_IROUTE_SUBNET=10.10.0.0/29
# KEYS_DIR=/etc/openvpn/server/keys
# LAST_IROUTE_SUBNET_FILE=/etc/openvpn/server/last_iroute_subnet
# N=2
# OPENVPN_GROUP=openvpn
# OPENVPN_USER=openvpn
# OS_SPECIFIC_OPTIONS  # WIN_SPECIFIC_OPTIONS or NIX_SPECIFIC_OPTIONS
# SERVER_CONF=/etc/openvpn/udp.server.conf
# SERVER_DIR=/etc/openvpn/server
# USER=00008-win-test
# USERS_CONF=/etc/openvpn/server/users-config
##

## Client config options
# OS_SPECIFIC_OPTIONS will be replaced to NIX_SPECIFIC_OPTIONS or WIN_SPECIFIC_OPTIONS depends on CLIENT_OS
read -rd '' CLIENT_CONFIG_TEMPLATE <<'EOF'
# OpenVPN 2.4 client \${CLIENT_OS} config file \${N} for host "\${HOST_NAME}"

# When  connecting to a remote server do not wait for more than n seconds
# waiting for a response before trying the next server. The default value is 120s.
# This timeout includes proxy and TCP connect timeouts.
server-poll-timeout 12

;remote-random
;local 192.168.1.\$((N%245+10))
nobind
${link_mtu} 1420
mssfix 0
server-poll-timeout 15

client
dev tun
cipher AES-256-GCM
auth SHA256
comp-lzo
resolv-retry infinite
remote-cert-tls server
sndbuf 0
rcvbuf 0
reneg-sec 0
verb 3
;mute 10

# For single connection persist-* and user/group options can be uncommented
# For dual it's better to keep them commented, otherwise openvpn cannot
# change connection without full restart
;persist-key
;persist-tun
;persist-remote-ip
auth-nocache

ignore-unknown-option block-outside-dns dhcp-renew register-dns tap-sleep dhcp-release dhcp-option

\${OS_SPECIFIC_OPTIONS}

<connection>
remote ${SERVER_PUBLIC_IP} 443 udp4
${mssfix} 1428
</connection>

<connection>
remote ${SERVER_PUBLIC_IP} 443 tcp4
mssfix 0
</connection>

# Certificates and keys
<ca>
\$(< "\${SERVER_DIR}/keys/ca.crt")
</ca>
<cert>
\$(< "\${EASYRSA}/pki/issued/\${USER}.crt")
</cert>
<key>
\$(< "\${EASYRSA}/pki/private/\${USER}.key")
</key>
key-direction 1
<tls-auth>
\$(< "\${SERVER_DIR}/keys/ta.key")
</tls-auth>
EOF

read -rd '' NIX_SPECIFIC_OPTIONS <<'EOF'
# *nix specific options (Linux/Mac/BSD)
;user openvpn
;group openvpn
nice 5
;log-append "/var/log/openvpn/\${USER}.log"
EOF
NIX_SPECIFIC_OPTIONS=\${NIX_SPECIFIC_OPTIONS/%\$'\n'}

read -rd '' WIN_SPECIFIC_OPTIONS <<'EOF'
# Windows specific options
block-outside-dns
dhcp-renew
register-dns
tap-sleep 1
EOF
WIN_SPECIFIC_OPTIONS=\${WIN_SPECIFIC_OPTIONS/%\$'\n'}

## Additional variables
# INITIAL_IROUTE_SUBNET=10.10.0.0/29
# LAST_IROUTE_SUBNET_FILE=\${SERVER_DIR}/last_iroute_subnet
# # Warning! Be careful - support of extended range of symbols could lead to script errors or unexpected behavior!
# HOST_NAME_ALLOWED_REGEX='^[A-Za-z0-9_-]+\$'  # Regex type of =~ bash operator (extended regular expression)
# ALLOW_DIFFERENT_CLIENT_TYPES_FOR_HOST=no

:  # For succesfull import
EOF_OPENVPN_MANAGE_CONF
echo "${OPENVPN_MANAGE_CONF}" >'/etc/openvpn/server/scripts/openvpn-manage.conf'


# To allow openvpn server listen on any IP uncomment line with `multihome` and comment `local` (comments is lines starts with ; or #) in openvpn server configs (and restart openvpn server).
# /etc/openvpn/server/tcp.server.conf  # Change SERVER_LOCAL_IP to interface local IP (could be different with public IP or the same)
read -rd '' TCP_SERVER_CONF <<EOF_TCP_SERVER_CONF
## OpenVPN 2.4 UDP server config file

# Must match IP of base network adapter
;local ${SERVER_LOCAL_IP}
multihome

# Base dir for options with relative paths
cd /etc/openvpn/chroot

## UDP server specific options
# proto udp4
# dev tun0
# # Keep client IP for a day (86400)
# ;ifconfig-pool-persist ipp.udp.server.txt 86400
# # Make replay-window twice larger due to laggy clients
# replay-window 80 20
# fast-io
# ${mssfix} 1428
# ${link_mtu} 1420
# ;connect-freq 20 1
# status /var/log/openvpn/status.udp.server.txt 10
# # journalctl will be used for logging too
# log-append /var/log/openvpn/udp.server.log
# replay-persist /var/log/openvpn/replay-persist.udp.server.txt
# # Management interface
# ;management /run/openvpn/mgmt.udp.server.socket unix
## END UDP server specific options

## TCP server specific options
proto tcp4
dev tun1
# Keep client IP for a day (86400)
;ifconfig-pool-persist /var/log/openvpn/ipp.tcp.server.txt 86400
mssfix 0
${link_mtu} 1420
tcp-nodelay
tcp-queue-limit 64
status /var/log/openvpn/status.tcp.server.txt 10
# journalctl will be used for logging too
log-append /var/log/openvpn/tcp.server.log
replay-persist /var/log/openvpn/replay-persist.tcp.server.txt
# Management interface
;management /run/openvpn/mgmt.tcp.server.socket unix
## END TCP server specific options

lport 443
server 172.16.16.0 255.255.255.0 nopool
# Reserve some small VPN IP's for possible internal needs
ifconfig-pool 172.16.16.0 172.16.16.254 255.255.255.0
# If you want traffic between clients go through firewall do not enable client-to-client
;client-to-client

# WARNING: --ifconfig-pool-persist will not work with --duplicate-cn
;duplicate-cn

topology subnet
;tun-mtu 1500
;tun-mtu-extra 0
;txqueuelen 500
status-version 1
tls-timeout 2

# On client side reneg-sec set to 0 by default,
# so this value (lowest positive) will be really used for most users
# 14400: 4h (default 3600: 1h)
reneg-sec 3600

ca /etc/openvpn/server/keys/ca.crt
cert /etc/openvpn/server/keys/server.crt
key /etc/openvpn/server/keys/server.key
dh /etc/openvpn/server/keys/dh.pem
crl-verify crl.pem
# tls-auth, replay-persist, connect-freq are good for basic DDoS protection
tls-auth /etc/openvpn/server/keys/ta.key 0

# Decrease openvpn process priority
nice 5

# Generally it's good to set proper max-clients value to avoid server freeze
max-clients 1024
;hash-size 1024 1024
;bcast-buffers 128

;management-client-user openvpn
;management-client-group openvpn

# Use separate user
user openvpn
group openvpn

;cipher AES-128-CBC
cipher AES-256-GCM
;auth SHA1
;auth ecdsa-with-SHA1
auth SHA256
tls-cipher TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256:TLS-DHE-RSA-WITH-AES-256-GCM-SHA384
tls-version-min 1.2
;opt-verify

;script-security 1
script-security 2
learn-address scripts/learn-address
;client-connect scripts/client-connect
;client-disconnect scripts/client-disconnect
ccd-exclusive
client-config-dir ccd
tmp-dir tmp

mute-replay-warnings
verb 4

keepalive 10 40
persist-key
persist-tun
persist-local-ip

# For uncompressable data (images, media) or high bandwidth better to use "comp-lzo no"
# For other cases "adaptive" or "yes"
comp-lzo adaptive
push "comp-lzo adaptive"

# For additional options see /etc/openvpn/server/users-config
# and per client configs in client-config-dir

chroot /etc/openvpn/chroot
EOF_TCP_SERVER_CONF
echo "${TCP_SERVER_CONF}" >'/etc/openvpn/server/tcp.server.conf'


# /etc/openvpn/server/udp.server.conf  # Clone from udp.server.conf via uncommenting udp block and commenting tcp
read -rd '' UDP_SERVER_CONF <<EOF_UDP_SERVER_CONF
## OpenVPN 2.4 UDP server config file

# Must match IP of base network adapter
;local ${SERVER_LOCAL_IP}
multihome

# Base dir for options with relative paths
cd /etc/openvpn/chroot

## UDP server specific options
proto udp4
dev tun0
# Keep client IP for a day (86400)
;ifconfig-pool-persist ipp.udp.server.txt 86400
# Make replay-window twice larger due to laggy clients
replay-window 80 20
fast-io
${mssfix} 1428
${link_mtu} 1420
;connect-freq 20 1
status /var/log/openvpn/status.udp.server.txt 10
# journalctl will be used for logging too
log-append /var/log/openvpn/udp.server.log
replay-persist /var/log/openvpn/replay-persist.udp.server.txt
# Management interface
;management /run/openvpn/mgmt.udp.server.socket unix
## END UDP server specific options

## TCP server specific options
# proto tcp4
# dev tun1
# # Keep client IP for a day (86400)
# ;ifconfig-pool-persist /var/log/openvpn/ipp.tcp.server.txt 86400
# ${link_mtu} 1420
# tcp-nodelay
# tcp-queue-limit 64
# status /var/log/openvpn/status.tcp.server.txt 10
# # journalctl will be used for logging too
# log-append /var/log/openvpn/tcp.server.log
# replay-persist /var/log/openvpn/replay-persist.tcp.server.txt
# # Management interface
# ;management /run/openvpn/mgmt.tcp.server.socket unix
## END TCP server specific options

lport 443
server 172.16.16.0 255.255.255.0 nopool
# Reserve some small VPN IP's for possible internal needs
ifconfig-pool 172.16.16.0 172.16.16.254 255.255.255.0
# If you want traffic between clients go through firewall do not enable client-to-client
;client-to-client

# WARNING: --ifconfig-pool-persist will not work with --duplicate-cn
;duplicate-cn

topology subnet
;tun-mtu 1500
;tun-mtu-extra 0
;txqueuelen 500
status-version 1
tls-timeout 2

# On client side reneg-sec set to 0 by default,
# so this value (lowest positive) will be really used for most users
# 14400: 4h (default 3600: 1h)
reneg-sec 3600

ca /etc/openvpn/server/keys/ca.crt
cert /etc/openvpn/server/keys/server.crt
key /etc/openvpn/server/keys/server.key
dh /etc/openvpn/server/keys/dh.pem
crl-verify crl.pem
# tls-auth, replay-persist, connect-freq are good for basic DDoS protection
tls-auth /etc/openvpn/server/keys/ta.key 0

# Decrease openvpn process priority
nice 5

# Generally it's good to set proper max-clients value to avoid server freeze
max-clients 1024
;hash-size 1024 1024
;bcast-buffers 128

;management-client-user openvpn
;management-client-group openvpn

# Use separate user
user openvpn
group openvpn

;cipher AES-128-CBC
cipher AES-256-GCM
;auth SHA1
;auth ecdsa-with-SHA1
auth SHA256
tls-cipher TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256:TLS-DHE-RSA-WITH-AES-256-GCM-SHA384
tls-version-min 1.2
;opt-verify

;script-security 1
script-security 2
learn-address scripts/learn-address
;client-connect scripts/client-connect
;client-disconnect scripts/client-disconnect
ccd-exclusive
client-config-dir ccd
tmp-dir tmp

mute-replay-warnings
verb 4

keepalive 10 40
persist-key
persist-tun
persist-local-ip

# For uncompressable data (images, media) or high bandwidth better to use "comp-lzo no"
# For other cases "adaptive" or "yes"
comp-lzo adaptive
push "comp-lzo adaptive"

# For additional options see /etc/openvpn/server/users-config
# and per client configs in client-config-dir

chroot /etc/openvpn/chroot
EOF_UDP_SERVER_CONF
echo "${UDP_SERVER_CONF}" >'/etc/openvpn/server/udp.server.conf'
## END Create configs

## Configure SELinux if required
if hash sestatus 2>/dev/null && sestatus | grep -q 'SELinux status:\s\+enabled'; then
    echo 'SELinux enabled, creating the rule to allow openvpn server to run on non standard UDP port 443...'
    hash semanage 2>/dev/null || yum -y -d0 install policycoreutils-python
    semanage port -a -t openvpn_port_t -p udp 443
fi

echo 'Stop/Start OpenVPN server'
if pidof systemd >/dev/null; then  # CentOS 7, Ubuntu Xenial
    systemctl stop openvpn@udp.server.service
    systemctl stop openvpn@tcp.server.service
    systemctl start openvpn@udp.server.service
    systemctl start openvpn@tcp.server.service
else  # CentOS 6, Ubuntu Trusty
    service openvpn stop
    service openvpn start
fi
echo 'Sleeping for 5 sec to give openvpn server time to start...'
sleep 5

## Check log
echo $'\n''Tail of udp.server.log:'
tail /var/log/openvpn/udp.server.log
echo $'\n''Tail of tcp.server.log:'
tail /var/log/openvpn/tcp.server.log
echo

read -rd '' IPTABLES_RULES <<EOF_IPTABLES_RULES
## Forwarding setup
iptables -P FORWARD DROP
iptables -I FORWARD -i tun+ -o ${SERVER_LOCAL_IF} -j ACCEPT
iptables -I FORWARD -i ${SERVER_LOCAL_IF} -o tun+ -j ACCEPT

## Enable SNAT (default). For dynamic server IP use "-j MASQUERADE" instead of "-j SNAT ..."
iptables -t nat -A POSTROUTING -o ${SERVER_LOCAL_IF}  -j SNAT --to-source ${SERVER_LOCAL_IP}
## Different SNAT for specific VPN clients. E.g.:
# iptables -t nat -I POSTROUTING -s 172.16.16.2 -o ${SERVER_LOCAL_IF}  -j SNAT --to-source SERVER_LOCAL_IP1
# iptables -t nat -I POSTROUTING -s 172.16.16.3 -o ${SERVER_LOCAL_IF}  -j SNAT --to-source SERVER_LOCAL_IP2
# iptables -t nat -I POSTROUTING -s 172.16.16.4 -o ${SERVER_LOCAL_IF}  -j SNAT --to-source SERVER_LOCAL_IP3
# ...

## Open ports (if required)
iptables -I INPUT 1 -p udp --dport 443 -i ${SERVER_LOCAL_IF} -j ACCEPT
iptables -I INPUT 1 -p tcp --dport 443 -i ${SERVER_LOCAL_IF} -j ACCEPT
EOF_IPTABLES_RULES

echo 'Evaluate iptables rules and save'
# Evaluate
eval "${IPTABLES_RULES}"
# Save
if [[ "${OS_family}" == 'RedHat' ]]; then
    service iptables save
else
    netfilter-persistent save
    netfilter-persistent reload
fi

echo 'Setup /etc/rc.local for forwarding'
sed -i 's/^exit 0$//' /etc/rc.local
comment='OpenVPN forwarding'
sed -i "/^# ${comment}/,/^# END ${comment}/d" /etc/rc.local  # Remove OpenVPN forwarding rules from rc.local
IPTABLES_RULES_COMMENTED=${IPTABLES_RULES//$'\n'/$'\n'# }
read -rd '' RC_LOCAL <<EOF_RC_LOCAL
## ${comment}
echo 1 >/proc/sys/net/ipv4/ip_forward

# Saved to /etc/sysconfig/iptables, so commented here
# ${IPTABLES_RULES_COMMENTED}
## END ${comment}

exit 0
EOF_RC_LOCAL
echo $'\n'"${RC_LOCAL}" >>/etc/rc.local
echo 1 >/proc/sys/net/ipv4/ip_forward

echo 'It is possible that you need to adopt firewall (iptables rules) to your setup, refer comments in /etc/rc.local'
# echo '/etc/rc.local content:'
# cat /etc/rc.local
# echo 'END of /etc/rc.local'

echo '
Make sure you have opened ports for openvpn server in VPS firewall (443 tcp and udp in this case)
If your VM/VPS has local firewall rules you probably have to change iptables rules to fit them and save them.
'
echo 'Firewall status:'
# iptables -vnL; echo; iptables -vnL -t nat
if ((CentOS_major == 6)); then
    service iptables status
else
    iptables -vnL
    echo $'\n'
    iptables -t nat -vnL
fi

## Create client certs/configs
# echo 'Creating test openvpn user:'
# openvpn-manage create test
echo 'To add users use: sudo openvpn-manage create usernamehere'
echo 'For help run openvpn-manage without arguments'
echo 'To download all configs locally you can run on your PC:'${BR}"scp root@${SERVER_PUBLIC_IP}:/etc/openvpn/server/client-packs/*/*.*[fn] ./"

echo 'Configuration completed'
